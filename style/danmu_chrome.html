<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Danmu å­¦ä¹ ç¬”è®° - ReadSense é£æ ¼</title>

    <link rel="icon" type="image/png" href="https://raw.githubusercontent.com/moodHappy/moodHappy.gitHub.io-nce/refs/heads/main/icon/danmu.png">
    <link rel="apple-touch-icon" href="https://raw.githubusercontent.com/moodHappy/moodHappy.gitHub.io-nce/refs/heads/main/icon/danmu.png">

    <style>
        :root {
            --primary: #0969da;
            --bg: #f6f8fa;
            --card-bg: #ffffff;
            --border: #d0d7de;
            --text-main: #1f2328;
            --text-muted: #656d76;
            
            /* é«˜äº®é¢œè‰²é…ç½® */
            --hl-blue: #0969da; 
            --hl-red: #cf222e; 
            --hl-yellow: #d97706; /* ã€ä¿®æ”¹ç‚¹1ã€‘æ–°å¢é»„è‰²å˜é‡ (ä½¿ç”¨ç¥ç€è‰²ä»¥ä¿è¯å¯è¯»æ€§) */
            
            /* ReadSense ç‰¹æœ‰æ ·å¼å˜é‡ */
            --rs-blue: #3498db;
            --rs-meta-bg: #f9f9f9;
            --rs-meta-text: #7f8c8d;
            --rs-title: #2c3e50;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg);
            color: var(--text-main);
            margin: 0;
            padding: 0;
            line-height: 1.6;
        }

        /* --- è§†å›¾1ï¼šåˆ—è¡¨å®¹å™¨ --- */
        .view-container {
            max-width: 800px; margin: 20px auto; background: var(--card-bg);
            border: 1px solid var(--border); border-radius: 6px; padding: 20px;
            box-shadow: 0 3px 6px rgba(140, 149, 159, 0.03); display: block;
        }

        /* --- è§†å›¾2ï¼šé˜…è¯»é¡µé¢ (ReadSense é£æ ¼å¤åˆ») --- */
        .reader-page {
            display: none; background: #ffffff; min-height: 100vh; width: 100%;
        }

        .reader-content-wrapper {
            max-width: 800px; margin: 0 auto; padding: 30px 20px 80px 20px;
            font-size: 18px; line-height: 1.8; color: #333;
        }

        /* 1. æ ‡é¢˜æ ·å¼ */
        .reader-content-wrapper h1 {
            display: block !important;
            margin-top: 25px;
            margin-bottom: 25px;
            line-height: 1.3;
            color: var(--rs-title);
            border-bottom: 2px solid var(--rs-blue);
            padding-bottom: 10px;
            font-size: 2em;
        }

        /* 2. å…ƒæ•°æ®å¡ç‰‡ */
        .meta {
            font-size: 14px;
            color: var(--rs-meta-text);
            margin-bottom: 25px;
            background: var(--rs-meta-bg);
            padding: 10px;
            border-radius: 6px;
            line-height: 1.6;
        }
        .meta div { margin-bottom: 4px; }
        .meta div:last-child { margin-bottom: 0; }
        .meta a { color: var(--rs-blue); text-decoration: none; word-break: break-all; }
        .meta a:hover { text-decoration: underline; }

        .content { background: #fff; }
        .reader-content-wrapper img { max-width: 100%; height: auto; display: block; margin: 20px auto; }
        
        .footer {
            margin-top: 40px; font-size: 12px; color: #bdc3c7; text-align: center; border-top: 1px solid #eee; padding-top: 20px;
        }

        /* --- åˆ—è¡¨ä¸å¤´éƒ¨é€šç”¨æ ·å¼ --- */
        header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; border-bottom: 1px solid var(--border); padding-bottom: 15px; }
        header h1 { margin: 0; font-size: 18px; display: flex; align-items: center; gap: 8px; border-bottom: none !important; color: inherit !important; }
        .status-badge { font-size: 12px; padding: 2px 6px; border-radius: 4px; background: #eee; color: #666; font-weight: normal; }
        .status-ready { background: #dafbe1; color: #1f883d; }
        .nav-btn { background: transparent; border: 1px solid var(--border); padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 14px; display: flex; align-items: center; gap: 5px; color: var(--text-main); }
        .nav-btn:hover { background: #f3f4f6; }

        ul { list-style: none; padding: 0; margin: 0; }
        li { border-bottom: 1px solid #eaecef; }
        li:last-child { border-bottom: none; }
        .list-item { display: flex; justify-content: space-between; align-items: center; padding: 12px 10px; cursor: pointer; border-radius: 4px; }
        .list-item:hover { background-color: #f6f8fa; }
        .item-icon { margin-right: 10px; font-size: 18px; }
        .folder-icon { color: #54aeff; }
        .file-icon { color: var(--text-muted); }
        .item-info { flex-grow: 1; overflow: hidden; }
        .item-name { font-weight: 600; font-size: 15px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; display: block; }
        .item-meta { font-size: 12px; color: var(--text-muted); margin-top: 2px; }
        .breadcrumb { background: #f3f4f6; padding: 10px 15px; border-radius: 6px; margin-bottom: 20px; font-size: 14px; display: flex; align-items: center; flex-wrap: wrap; }
        .breadcrumb-item { cursor: pointer; color: var(--primary); font-weight: 500; }
        .breadcrumb-separator { margin: 0 8px; color: var(--text-muted); }
        .breadcrumb-current { color: var(--text-muted); pointer-events: none; }
        .pinned-section { background: #e6f6ff; border: 1px solid #b6e3ff; border-radius: 6px; padding: 15px; margin-bottom: 20px; }
        .pinned-label { font-size: 12px; font-weight: bold; color: #0969da; text-transform: uppercase; margin-bottom: 8px; display: block; }
        .pinned-card { display: flex; justify-content: space-between; align-items: center; cursor: pointer; }
        .pinned-title { font-size: 16px; font-weight: 700; color: #1f2328; }
        .pinned-meta { font-size: 12px; color: #57606a; margin-top: 4px; }

        /* é«˜äº®æ ·å¼ */
        .hl-blue { color: var(--hl-blue); font-weight: 700; }
        .hl-red { color: var(--hl-red); font-weight: 700; }
        /* ã€ä¿®æ”¹ç‚¹2ã€‘æ·»åŠ é»„è‰²æ ·å¼ç±» */
        .hl-yellow { color: var(--hl-yellow); font-weight: 700; }

        /* è®¾ç½®å¼¹çª— */
        .modal-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.4); z-index: 200; justify-content: center; align-items: center; }
        .modal { background: white; padding: 25px; border-radius: 8px; width: 90%; max-width: 400px; box-shadow: 0 10px 25px rgba(0,0,0,0.2); }
        .form-group { margin-bottom: 15px; } .form-group label { display: block; margin-bottom: 5px; font-size: 13px; font-weight: bold; } .form-group input { width: 100%; padding: 8px; box-sizing: border-box; border: 1px solid #d0d7de; border-radius: 4px; }
        .btn { padding: 8px 16px; cursor: pointer; border: none; border-radius: 4px; font-size: 14px; } .btn-secondary { background: #f3f4f6; color: #24292f; margin-right: 10px; } .btn-primary { background: var(--primary); color: white; }
        .loading, .error { text-align: center; padding: 50px 20px; color: var(--text-muted); font-size: 16px; } .error { color: #cf222e; }
    </style>
</head>
<body>

<div id="list-view" class="view-container">
    <header>
        <h1>ğŸ“š è‹±è¯­å­¦ä¹ ç¬”è®° <span id="dict-status" class="status-badge">è¯åº“åŠ è½½ä¸­...</span></h1>
        <button class="nav-btn" onclick="openSettings()"><span>âš™ï¸ è®¾ç½®</span></button>
    </header>
    <div id="breadcrumb" class="breadcrumb"></div>
    <div id="latest-container"></div>
    <div id="file-list"><div class="loading">æ­£åœ¨åŠ è½½ç›®å½•...</div></div>
</div>

<div id="reader-view" class="reader-page">
    <div id="reader-content" class="reader-content-wrapper"></div>
</div>

<div id="settings-modal" class="modal-overlay">
    <div class="modal">
        <h3>ğŸ”§ é…ç½®</h3>
        <div class="form-group"><label>GitHub Token (PAT)</label><input type="password" id="cfg-token" placeholder="github_pat_..."><div style="font-size:12px; color:#666; margin-top:4px;">ğŸ”’ Token ä¿å­˜åœ¨æœ¬åœ°ã€‚</div></div>
        <div class="form-group"><label>GitHub ç”¨æˆ·å</label><input type="text" id="cfg-user"></div>
        <div class="form-group"><label>ä»“åº“åç§°</label><input type="text" id="cfg-repo"></div>
        <div class="form-group"><label>æ ¹ç›®å½•è·¯å¾„</label><input type="text" id="cfg-root"></div>
        <div style="text-align: right; margin-top: 20px;"><button class="btn btn-secondary" onclick="closeSettings()">å–æ¶ˆ</button><button class="btn btn-primary" onclick="saveSettings()">ä¿å­˜å¹¶åˆ·æ–°</button></div>
    </div>
</div>

<script>
    const DEFAULTS = { user: 'moodHappy', repo: 'moodHappy.gitHub.io-nce', rootPath: 'Notes/danmu', token: '' };
    const DICT_URLS = {
        one: 'https://raw.githubusercontent.com/moodHappy/HelloWorld/refs/heads/master/Notes/one.txt',
        two: 'https://raw.githubusercontent.com/moodHappy/HelloWorld/refs/heads/master/Notes/two.txt',
        supplement: 'https://raw.githubusercontent.com/moodHappy/HelloWorld/refs/heads/master/Notes/supplement.txt',
        excluded: 'https://raw.githubusercontent.com/moodHappy/HelloWorld/refs/heads/master/Notes/Excluded.txt'
    };

    let config = {}; let currentPath = ''; let dictMap = new Map(); let isDictLoaded = false;

    window.addEventListener('popstate', (event) => {
        if (!new URLSearchParams(window.location.search).has('file')) showListUI();
    });

    function getConfig() {
        const stored = localStorage.getItem('gh_nav_config_v5');
        return stored ? { ...DEFAULTS, ...JSON.parse(stored) } : DEFAULTS;
    }

    async function init() {
        config = getConfig();
        if (!currentPath) currentPath = config.rootPath;
        const targetFile = new URLSearchParams(window.location.search).get('file');
        loadDictionaries(); 
        if (targetFile) openReader(targetFile, false); else loadPath(currentPath);
    }

    async function loadDictionaries() {
        const statusEl = document.getElementById('dict-status');
        try {
            const [txtOne, txtTwo, txtSup, txtExc] = await Promise.all([
                fetch(DICT_URLS.one).then(r => r.text()), fetch(DICT_URLS.two).then(r => r.text()),
                fetch(DICT_URLS.supplement).then(r => r.text()), fetch(DICT_URLS.excluded).then(r => r.text())
            ]);
            const parse = (text) => text.split(/\r?\n/).map(w => w.trim().toLowerCase()).filter(w => w);
            const excludedSet = new Set(parse(txtExc));
            
            // è¯åº“é…ç½®åŒºåŸŸ
            parse(txtOne).forEach(w => { if(!excludedSet.has(w)) dictMap.set(w, 'hl-blue'); });
            parse(txtTwo).forEach(w => { if(!excludedSet.has(w)) dictMap.set(w, 'hl-red'); });
            
            // ã€ä¿®æ”¹ç‚¹3ã€‘å°† supplement è¯æ±‡æ˜ å°„åˆ° hl-yellow
            parse(txtSup).forEach(w => { if(!excludedSet.has(w)) dictMap.set(w, 'hl-yellow'); });
            
            isDictLoaded = true;
            statusEl.textContent = `âœ“ è¯åº“å°±ç»ª (${dictMap.size}è¯)`; statusEl.classList.add('status-ready');
            if(document.getElementById('reader-view').style.display === 'block') applyHighlights(document.getElementById('reader-content'));
        } catch (e) {
            statusEl.textContent = "âš ï¸ è¯åº“å¤±è´¥"; statusEl.style.background = "#ffebe9"; statusEl.style.color = "#cf222e";
        }
    }

    async function ghFetch(url) {
        const headers = {}; if (config.token) headers['Authorization'] = `token ${config.token}`;
        const response = await fetch(url, { headers });
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        return await response.json();
    }

    async function loadPath(path) {
        currentPath = path; renderBreadcrumb(path);
        const listContainer = document.getElementById('file-list');
        const latestContainer = document.getElementById('latest-container');
        listContainer.innerHTML = '<div class="loading">æ­£åœ¨è·å–åˆ—è¡¨...</div>';
        try {
            const data = await ghFetch(`https://api.github.com/repos/${config.user}/${config.repo}/contents/${path}`);
            if (!Array.isArray(data)) return; 
            let dirs = [], files = []; processItems(data, dirs, files);
            dirs.sort((a, b) => b.name.localeCompare(a.name)); files.sort((a, b) => b.timestamp - a.timestamp);
            
            if (path === config.rootPath) {
                const yearDirs = dirs.filter(d => /^\d{4}$/.test(d.name));
                if (yearDirs.length > 0) {
                    latestContainer.innerHTML = '<div style="text-align:center;color:#999;font-size:12px;margin-bottom:10px;">æ­£åœ¨æ£€æŸ¥æœ€æ–°ç¬”è®°...</div>';
                    fetchLatestInDir(yearDirs[0]).then(latest => {
                        if (latest) renderLatestCard(latest, yearDirs[0].name); else latestContainer.innerHTML = '';
                    });
                } else { latestContainer.innerHTML = ''; }
            } else { latestContainer.innerHTML = ''; }
            renderList(dirs, files);
        } catch (error) { listContainer.innerHTML = `<div class="error">${error.message}</div>`; }
    }

    function processItems(items, dirsArr, filesArr) {
        items.forEach(item => {
            if (item.name.toLowerCase() === 'index.html') return;
            if (item.type === 'dir') dirsArr.push(item);
            else if (item.name.endsWith('.html')) {
                const match = item.name.match(/_(\d{13})\.html$/);
                const ts = match ? parseInt(match[1]) : 0;
                filesArr.push({ ...item, timestamp: ts, dateStr: ts ? new Date(ts).toLocaleString('zh-CN',{hour12:false}) : '' });
            }
        });
    }

    async function fetchLatestInDir(dirItem) {
        const data = await ghFetch(`https://api.github.com/repos/${config.user}/${config.repo}/contents/${dirItem.path}`);
        if (!Array.isArray(data)) return null;
        let files = [], dirs = []; processItems(data, dirs, files);
        files.sort((a, b) => b.timestamp - a.timestamp); return files.length > 0 ? files[0] : null;
    }

    function renderList(dirs, files) {
        const listContainer = document.getElementById('file-list');
        if (dirs.length === 0 && files.length === 0) { listContainer.innerHTML = '<div style="text-align:center;padding:30px;color:#999;">ç©ºç›®å½•</div>'; return; }
        let html = '<ul>';
        dirs.forEach(dir => html += `<li onclick="loadPath('${dir.path}')"><div class="list-item"><span class="item-icon folder-icon">ğŸ“</span><div class="item-info"><span class="item-name">${dir.name}</span></div><span style="color:#ccc">â€º</span></div></li>`);
        files.forEach(file => {
            let displayName = file.name.replace('.html', '').replace(/_\d{13}$/, '').replace(/_/g, ' ');
            html += `<li onclick="openReader('${file.path}')"><div class="list-item"><span class="item-icon file-icon">ğŸ“„</span><div class="item-info"><span class="item-name">${displayName}</span>${file.dateStr ? `<div class="item-meta">ğŸ“… ${file.dateStr}</div>` : ''}</div></div></li>`;
        });
        html += '</ul>'; listContainer.innerHTML = html;
    }

    function renderLatestCard(file, year) {
        const container = document.getElementById('latest-container');
        let displayName = file.name.replace('.html', '').replace(/_\d{13}$/, '').replace(/_/g, ' ');
        container.innerHTML = `<div class="pinned-section"><span class="pinned-label">ğŸ†• æœ€æ–°ç¬”è®° (${year})</span><div class="pinned-card" onclick="openReader('${file.path}')"><div style="display:flex;align-items:center;overflow:hidden;"><span class="pinned-icon">ğŸ“„</span><div style="overflow:hidden;"><div class="pinned-title" style="white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${displayName}</div><div class="pinned-meta">ğŸ“… ${file.dateStr}</div></div></div><div style="color:#0969da;font-weight:bold;margin-left:10px;">é˜…è¯» &rarr;</div></div></div>`;
    }

    function renderBreadcrumb(path) {
        const container = document.getElementById('breadcrumb');
        let html = `<span class="breadcrumb-item" onclick="loadPath('${config.rootPath}')">ğŸ  é¦–é¡µ</span>`;
        if (path !== config.rootPath && path.startsWith(config.rootPath)) {
            const parts = path.substring(config.rootPath.length).split('/').filter(p=>p);
            let build = config.rootPath;
            parts.forEach((part, i) => {
                build += '/' + part; html += `<span class="breadcrumb-separator">/</span>`;
                if(i===parts.length-1) html += `<span class="breadcrumb-current">${part}</span>`; else html += `<span class="breadcrumb-item" onclick="loadPath('${build}')">${part}</span>`;
            });
        }
        container.innerHTML = html;
    }

    function showListUI() {
        document.getElementById('list-view').style.display = 'block'; document.getElementById('reader-view').style.display = 'none';
        document.body.style.backgroundColor = 'var(--bg)'; 
        const url = new URL(window.location); url.searchParams.delete('file'); history.replaceState(null, '', url); window.scrollTo(0, 0);
    }
    function showReaderUI() {
        document.getElementById('list-view').style.display = 'none'; document.getElementById('reader-view').style.display = 'block';
        document.body.style.backgroundColor = '#ffffff'; window.scrollTo(0, 0);
    }

    async function openReader(filePath, updateHistory = true) {
        showReaderUI();
        const contentEl = document.getElementById('reader-content');
        if (updateHistory) { const url = new URL(window.location); url.searchParams.set('file', filePath); history.pushState({ file: filePath }, '', url); }
        contentEl.innerHTML = '<div class="loading">æ­£åœ¨åŠ è½½ç¬”è®°å†…å®¹...</div>';

        try {
            const response = await fetch(`https://raw.githubusercontent.com/${config.user}/${config.repo}/main/${filePath}`);
            if (!response.ok) throw new Error("HTTP " + response.status);
            const htmlText = await response.text();

            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlText, 'text/html');

            const h1 = doc.querySelector('h1');
            
            let timeText = '';
            let linkHtml = '';
            let nodesToRemove = [];

            const existingMeta = doc.querySelector('.meta');
            if (existingMeta) {
                timeText = existingMeta.textContent.match(/å½’æ¡£æ—¶é—´:([^\n]*)/)?.[1] || '';
                const linkTag = existingMeta.querySelector('a');
                if (linkTag) linkHtml = linkTag.outerHTML;
                nodesToRemove.push(existingMeta);
            } else {
                let currentNode = h1 ? h1.nextElementSibling : doc.body.firstElementChild;
                while (currentNode) {
                    const text = currentNode.textContent;
                    if (text.includes('å½’æ¡£æ—¶é—´')) {
                        timeText = text.replace('å½’æ¡£æ—¶é—´:', '').replace('ğŸ“…', '').trim();
                        nodesToRemove.push(currentNode);
                    } else if (text.includes('åŸæ–‡é“¾æ¥') || currentNode.querySelector('a')) {
                        const linkTag = currentNode.querySelector('a');
                        if (linkTag) {
                            linkHtml = linkTag.outerHTML;
                        } else {
                            const urlMatch = text.match(/http[s]?:\/\/[^\s]+/);
                            if(urlMatch) linkHtml = `<a href="${urlMatch[0]}" target="_blank">${urlMatch[0]}</a>`;
                        }
                        nodesToRemove.push(currentNode);
                    }
                    if (nodesToRemove.length >= 2) break; 
                    currentNode = currentNode.nextElementSibling;
                }
            }

            nodesToRemove.forEach(n => n.remove());

            const metaDiv = document.createElement('div');
            metaDiv.className = 'meta';
            if (timeText) {
                const dateRow = document.createElement('div');
                dateRow.innerHTML = `ğŸ“… å½’æ¡£æ—¶é—´: ${timeText.trim()}`;
                metaDiv.appendChild(dateRow);
            }
            if (linkHtml) {
                const linkRow = document.createElement('div');
                linkRow.innerHTML = `ğŸ”— åŸæ–‡é“¾æ¥: ${linkHtml}`;
                metaDiv.appendChild(linkRow);
            }

            if (h1 && h1.parentNode) {
                h1.parentNode.insertBefore(metaDiv, h1.nextSibling);
            } else {
                doc.body.insertBefore(metaDiv, doc.body.firstChild);
            }

            if (!doc.querySelector('.footer')) {
                const footer = document.createElement('div');
                footer.className = 'footer';
                footer.textContent = 'Generated by ReadSense UserScript';
                doc.body.appendChild(footer);
            }

            contentEl.innerHTML = doc.body.innerHTML;
            if (isDictLoaded) applyHighlights(contentEl);

        } catch (e) { contentEl.innerHTML = `<div class="error">åŠ è½½å¤±è´¥: ${e.message}<br><button class="btn btn-secondary" onclick="location.reload()" style="margin-top:20px;">é‡è¯•</button></div>`; }
    }

    function applyHighlights(rootElement) {
        if (dictMap.size === 0) return;
        const walker = document.createTreeWalker(rootElement, NodeFilter.SHOW_TEXT, null, false);
        const textNodes = []; let node;
        while(node = walker.nextNode()) {
            const parent = node.parentElement;
            if (parent.tagName !== 'SCRIPT' && 
                parent.tagName !== 'STYLE' && 
                !parent.closest('.meta') && 
                !parent.closest('.footer')) {
                textNodes.push(node);
            }
        }
        const regex = /\b[a-zA-Z][a-zA-Z'-]*\b/g;
        textNodes.forEach(textNode => {
            const text = textNode.nodeValue; if (!text.trim()) return;
            const fragment = document.createDocumentFragment(); let lastIndex = 0; let match;
            while ((match = regex.exec(text)) !== null) {
                const word = match[0]; const lowerWord = word.toLowerCase();
                if (dictMap.has(lowerWord)) {
                    if (match.index > lastIndex) fragment.appendChild(document.createTextNode(text.substring(lastIndex, match.index)));
                    const span = document.createElement('span'); span.className = dictMap.get(lowerWord); span.textContent = word;
                    fragment.appendChild(span); lastIndex = regex.lastIndex;
                }
            }
            if (lastIndex > 0) {
                if (lastIndex < text.length) fragment.appendChild(document.createTextNode(text.substring(lastIndex)));
                textNode.parentNode.replaceChild(fragment, textNode);
            }
        });
    }

    function openSettings() { document.getElementById('settings-modal').style.display = 'flex'; document.getElementById('cfg-user').value = config.user; document.getElementById('cfg-repo').value = config.repo; document.getElementById('cfg-root').value = config.rootPath; document.getElementById('cfg-token').value = config.token || ''; }
    function closeSettings() { document.getElementById('settings-modal').style.display = 'none'; }
    function saveSettings() {
        const newConfig = { user: document.getElementById('cfg-user').value.trim(), repo: document.getElementById('cfg-repo').value.trim(), rootPath: document.getElementById('cfg-root').value.trim().replace(/\/+$/, ''), token: document.getElementById('cfg-token').value.trim() };
        localStorage.setItem('gh_nav_config_v5', JSON.stringify(newConfig)); closeSettings(); location.reload();
    }
    document.getElementById('settings-modal').addEventListener('click', function(e) { if (e.target === this) closeSettings(); });
    init();
</script>
</body>
</html>
